# 1、反射

## 1.1、反射是什么，能干嘛

反射机制的核心就是在程序运行时候动态加载类并获取类的详细信息，然后操作类中的属性和方法。本质上是jvm的得到class对象以后，再通过class对象进行反编译。

Java的加载过程 .java文件先编译 ----> 形成 .class 文件 -----> 然后加载到内存中，此时内存中就有了一个class对象。

## 1.2、反射的优缺点

缺点：反射会消耗一定的系统资源，所有如果不需要动态地创建一个对象，那么就不要使用反射；其次反射可以忽略安全检查，破环封装性从而导致安全的问题。

## 1.3、获取class对象的几种方式

+ 通过类名.class 示例：Student.class
+ 通过class.forName("包路径") 的方式 示例：class.forName("com.code.reflection.bean.Student")
+ 通过对象.getClass()的方式 示例：Student stu = new Student(); stu.getClass();

## 1.4、操作构造器

+ getConstructors() 获取全部的构造器，注意只能获取到构造器是public类型修饰的

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448059394-0ffce567-0ee5-4070-9f57-32597ca173a6.png)

+ getDeclaredConstructors() 获取全部的构造器，可以拿到任意修饰类型的构造器

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448059360-5ac427a1-8708-4cf1-acb8-77eb60ff3203.png)

+ getConstructor() 获取指定类型的构造器，只可以获取public修饰的

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448059303-774b741c-113a-49ab-8419-1305b18a1147.png)

+ getDeclaredConstructor() 获取指定类型的构造器，可以获取任意修饰类型的

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448059301-b533160a-ac5e-4885-8eb5-63239a994c62.png)

## 1.5、通过反射拿到对象

+ newInstance 完成对象的初始化并且返回
+ setAccessible(Boolean flag) 设置成true，表示禁止检查访问控制（暴力反射）

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448059335-de01b0d0-1975-4c82-a74d-ba0271f45d38.png)

## 1.6、操作成员变量

+ getFields() 获取所有的属性（只能获取public修饰的）

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060035-5c81a7d8-00e5-4eb8-8a83-e5b574a1a127.png)

+ getDeclaredFields() getDeclaredFields 获取所有的属性（可以获取任意权限修饰的属性）

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060118-64f23933-6c66-4139-9ca9-50090a7794cd.png)

+ getField("属性名") 获取某个特定的属性 (只能获取public修饰的)

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060127-7ed44515-18ae-4598-aab2-2e2984946a03.png)

+ getDeclaredField("属性名") 获取所有的属性（可以获取任意权限修饰的属性）

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060079-10083dae-72dd-47ca-884c-2b05bc164b13.png)

## 1.7、操作成员方法

+ getMethods() 获取类的全部成员方法（只能获取public修饰的）

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060096-d57338e9-c27e-435b-9ef0-6c422a2bd1eb.png)

+ getDeclaredMethods() 获取类的全部成员方法，可以获取到任意权限修饰

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060633-30b8d487-79b7-4c7d-b830-06a88eaf6481.png)

+ getMethod(String name, Class... paramterType) 获取类的成员方法，只能获取public修饰的

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060584-81d1b5a6-fef1-4b49-8586-9bdecb881470.png)

+ getDeclaredMethod(String name, Class... paramterType) 获取类的成员方法，可以获取任意权限修饰的属性

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060599-1a672b9a-76d8-4456-b33b-2e289d7164fb.png)

# 2、注解

## 2.1、注解是什么，能干嘛

注解就是一个标签，这个标签可以标注在方法上、类上、属性上。然后通过反射去判断这个类上、方法上、属性上是否含有某个标签，然后根据不同的标签去执行不同的动作。

自定义注解

```java
public @interface 注解名称 {
    public 属性类型 属性名 default 默认值;
}
```

注解中的特殊属性value，如果注解中只有这一个属性，那么在使用注解的时候就可以不写这个名字，如果有多个属性则必须写上这个名字。

```java
public @interface MyAnnotation {
    String value();
}
```

注解的本质，注解的本质就是一个接口，其中所有的接口都是继承了annotation的。

```java

public interface Override extends Annotation{

}
```

注解内部的数据实质上是一个接口方法

```java
public String test() default "";
```

## 2.2、元注解

修饰注解的注解

![](https://cdn.nlark.com/yuque/0/2024/png/12477403/1721448060745-c647c04a-18e4-4c4f-8f54-d81834b94af2.png)

最常见的两个元注解

+ @Target 作用：声明被修饰的注解只能应用在哪些位置上使用。
  - ElementType.TYPE 类上、接口上
  - ElementType.FIELD 成员变量上
  - ElementType.METHOD 方法上
  - ElementType.PARAMETER 方法参数上
  - ElementType.CONSTRUCTOR 构造器上
  - ElementType.VARIABLE 局部变量上
+ @Retention作用：声明注解的保留周期
  - RetentionPolicy.SOURCE 只作用在源码阶段，编译成字节码以后就不存在了
  - RetentionPolicy.CLASS (默认) 保留到字节码文件阶段，运行阶段不存在
  - RetentionPolicy.RUNTIME (开发常用) 一直保留到运行阶段

## 2.3、注解的解析

注解的解析就是将类上、方法上、属性上的注解信息给解析出来

遵循一个解析的原则：要解析谁就要拿到谁

注解解析示例

MyAnnotation注解

```java
@Target({ElementType.FIELD, ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String name() default "niuxiaoniu";
    boolean isWork() default false;
    String[] stuName();
}
```

MyAnnotationDemo类

```java
@MyAnnotation(name = "lxl",stuName = {"邯郸","唐山"})
public class MyAnnotationDemo {

    @MyAnnotation(name = "zzy",stuName = {"邯郸","北京"})
    public void test1(){

    }
}
```

AnalysAnnotation类去解析MyAnnotationDemo上面标注的注解

```java
public class AnalysAnnotation {
    @Test
    public void analys() throws NoSuchMethodException {
        Class<MyAnnotationDemo> myAnnotationDemoClass = MyAnnotationDemo.class;
        if (myAnnotationDemoClass.isAnnotationPresent(MyAnnotation.class)){
            MyAnnotation declaredAnnotation = myAnnotationDemoClass.getDeclaredAnnotation(MyAnnotation.class);
            System.out.println(declaredAnnotation.name());
            System.out.println(declaredAnnotation.isWork());
            System.out.println(Arrays.toString(declaredAnnotation.stuName()));
        }
        System.out.println("---------- 开始解析方法上的注解 -----------");
        Method m = myAnnotationDemoClass.getMethod("test1");
        if (m.isAnnotationPresent(MyAnnotation.class)){
            MyAnnotation declaredAnnotationMethod = m.getDeclaredAnnotation(MyAnnotation.class);
            System.out.println(declaredAnnotationMethod.name());
            System.out.println(declaredAnnotationMethod.isWork());
            System.out.println(Arrays.toString(declaredAnnotationMethod.stuName()));
        }
    }
}
```

+ isAnnotationPresent(Class<Annotation> annotationClass) 判断对象上是否存在某个注解
+ getDeclaredAnnotation(Class<T> annotationClass) 获取指定的注解对象
+ getDeclaredAnnotations() 获取当前对象上面的注解
